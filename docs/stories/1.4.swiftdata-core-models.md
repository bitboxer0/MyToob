# Story 1.4: SwiftData Core Models

## Status
Draft

## Story
**As a** developer,
**I want** SwiftData models defined for VideoItem, ClusterLabel, Note, and ChannelBlacklist,
**so that** the app can persist video metadata, AI results, user notes, and moderation preferences.

## Acceptance Criteria
1. `VideoItem` model created with properties: `videoID` (YouTube ID or nil for local), `localURL`, `title`, `channelID`, `duration`, `watchProgress`, `isLocal`, `aiTopicTags`, `embedding` (transformable [Float] array), `addedAt`, `lastWatchedAt`
2. `ClusterLabel` model created with properties: `clusterID`, `label`, `centroid` (transformable [Float] array), `itemCount`
3. `Note` model created with properties: `noteID`, `content` (Markdown string), `timestamp` (optional video position), `createdAt`, `updatedAt`, relationship to `VideoItem`
4. `ChannelBlacklist` model created with properties: `channelID` (unique), `reason` (optional), `blockedAt`
5. Models use `@Attribute(.unique)` for identity fields where appropriate
6. SwiftData model container configured in app entry point
7. Unit tests created for model creation, fetching, and deletion

## Tasks / Subtasks
- [ ] Create VideoItem model (AC: 1, 5)
  - [ ] Create `MyToob/Core/Models/VideoItem.swift` file
  - [ ] Add `@Model` macro to class
  - [ ] Define all required properties with correct types
  - [ ] Use `@Attribute(.unique)` for `id` property
  - [ ] Use `@Attribute(.transformable)` for `aiTopicTags` and `embedding` arrays
  - [ ] Add relationships to Note and Collection models
  - [ ] Implement initializer with default values
- [ ] Create ClusterLabel model (AC: 2, 5)
  - [ ] Create `MyToob/Core/Models/ClusterLabel.swift` file
  - [ ] Add `@Model` macro to class
  - [ ] Define all required properties
  - [ ] Use `@Attribute(.unique)` for `clusterID`
  - [ ] Use `@Attribute(.transformable)` for `centroid` array
  - [ ] Implement initializer
- [ ] Create Note model (AC: 3, 5)
  - [ ] Create `MyToob/Core/Models/Note.swift` file
  - [ ] Add `@Model` macro to class
  - [ ] Define all required properties
  - [ ] Use `@Attribute(.unique)` for `noteID`
  - [ ] Add `@Relationship` to VideoItem
  - [ ] Implement initializer
- [ ] Create ChannelBlacklist model (AC: 4, 5)
  - [ ] Create `MyToob/Core/Models/ChannelBlacklist.swift` file
  - [ ] Add `@Model` macro to class
  - [ ] Define all required properties
  - [ ] Use `@Attribute(.unique)` for `channelID`
  - [ ] Implement initializer
- [ ] Configure SwiftData model container (AC: 6)
  - [ ] Add SwiftData import to app entry point
  - [ ] Create ModelContainer with all models
  - [ ] Configure ModelContainer with appropriate schema
  - [ ] Inject ModelContext into SwiftUI environment
  - [ ] Handle container initialization errors
- [ ] Create unit tests (AC: 7)
  - [ ] Create `MyToobTests/Models/VideoItemTests.swift`
  - [ ] Create `MyToobTests/Models/ClusterLabelTests.swift`
  - [ ] Create `MyToobTests/Models/NoteTests.swift`
  - [ ] Create `MyToobTests/Models/ChannelBlacklistTests.swift`
  - [ ] Test model creation with valid data
  - [ ] Test model persistence and fetching
  - [ ] Test model deletion
  - [ ] Test relationship integrity (Note <-> VideoItem)
  - [ ] Test unique constraint violations

## Dev Notes

### SwiftData Model Definitions
[Source: architecture/data-models.md]

**VideoItem Model Structure:**
```swift
@Model
final class VideoItem {
    @Attribute(.unique) var id: UUID
    var videoID: String?  // YouTube: "dQw4w9WgXcQ", Local: nil
    var localURL: URL?
    var title: String
    var channelID: String?
    var channelTitle: String?
    var desc: String?  // "description" reserved keyword
    var duration: TimeInterval
    var thumbnailURL: URL?
    var watchProgress: TimeInterval
    var isLocal: Bool

    @Attribute(.transformable) var aiTopicTags: [String]
    @Attribute(.transformable) var embedding: [Float]?

    var addedAt: Date
    var lastWatchedAt: Date?
    var clusterID: String?

    @Relationship(deleteRule: .cascade) var notes: [Note]?
    @Relationship(inverse: \Collection.videos) var collections: [Collection]?
}
```

**ClusterLabel Model Structure:**
```swift
@Model
final class ClusterLabel {
    @Attribute(.unique) var clusterID: String
    var label: String
    @Attribute(.transformable) var centroid: [Float]
    var itemCount: Int
    var createdAt: Date
    var userEdited: Bool
}
```

**Note Model Structure:**
```swift
@Model
final class Note {
    @Attribute(.unique) var noteID: UUID
    var content: String
    var timestamp: TimeInterval?
    var createdAt: Date
    var updatedAt: Date

    @Relationship var video: VideoItem?
}
```

**ChannelBlacklist Model Structure:**
```swift
@Model
final class ChannelBlacklist {
    @Attribute(.unique) var channelID: String
    var reason: String?
    var blockedAt: Date
}
```

### Tech Stack
[Source: architecture/tech-stack.md]
- **Data Persistence:** SwiftData (macOS 14+)
- **Justification:** Modern replacement for Core Data, simpler API, automatic CloudKit sync support
- **Version:** Requires macOS 14.0+ minimum deployment target

### Coding Standards for SwiftData
[Source: architecture/coding-standards.md]
- **CRITICAL RULE:** Always use `@Model` macro and `@Attribute(.unique)` for identity fields
- **CRITICAL RULE:** Never manually manage object IDs
- Use `@Attribute(.transformable)` for arrays and complex types
- Use proper relationship delete rules (`.cascade`, `.nullify`, etc.)

### File Locations
[Source: architecture/unified-project-structure.md]
- All model files go in: `MyToob/Core/Models/`
- Model files: `VideoItem.swift`, `ClusterLabel.swift`, `Note.swift`, `ChannelBlacklist.swift`

### Model Relationships
- **VideoItem -> Note:** One-to-many with cascade delete (deleting video deletes its notes)
- **VideoItem -> Collection:** Many-to-many (video can be in multiple collections)
- **Note -> VideoItem:** Many-to-one (note belongs to one video)

### SwiftData Container Configuration
The ModelContainer should be configured in the app entry point (`MyToobApp.swift`):
```swift
@main
struct MyToobApp: App {
    let modelContainer: ModelContainer

    init() {
        do {
            modelContainer = try ModelContainer(
                for: VideoItem.self, ClusterLabel.self, Note.self,
                    ChannelBlacklist.self, Collection.self, FocusModeSettings.self
            )
        } catch {
            fatalError("Failed to initialize ModelContainer: \(error)")
        }
    }

    var body: some Scene {
        WindowGroup {
            ContentView()
        }
        .modelContainer(modelContainer)
    }
}
```

## Testing

### Testing Standards
[Source: architecture/testing-strategy.md]
- **Test Location:** `MyToobTests/Models/`
- **Test Framework:** XCTest
- **Coverage Target:** 80% for models

### Testing Requirements for This Story
**Unit Tests (Models category):**
- Model creation with valid data
- Model persistence (create -> save -> fetch)
- Model updates
- Model deletion
- Relationship integrity
- Unique constraint enforcement
- Transformable attribute serialization/deserialization

**Test File Structure:**
```
MyToobTests/
├── Models/
│   ├── VideoItemTests.swift
│   ├── ClusterLabelTests.swift
│   ├── NoteTests.swift
│   └── ChannelBlacklistTests.swift
```

**Example Test Pattern:**
```swift
@Test("VideoItem creation with valid data")
func testVideoItemCreation() async throws {
    let container = try ModelContainer(for: VideoItem.self)
    let context = ModelContext(container)

    let video = VideoItem(
        videoID: "test123",
        title: "Test Video",
        duration: 300
    )
    context.insert(video)
    try context.save()

    #expect(video.id != nil)
    #expect(video.title == "Test Video")
}
```

### Integration Tests
- Test SwiftData persistence: Write → read → update → delete cycles
- Test relationship cascades work correctly
- Test unique constraint violations throw appropriate errors

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-11-17 | 1.0 | Initial story creation | Scrum Master (Bob) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes List
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_
